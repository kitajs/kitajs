import { kSchemaDefinitions, type JsonSchema, type KitaPlugin, type Provider, type Route } from '@kitajs/common';
import stringify from 'json-stable-stringify';
import { tst } from '../util/template';
import { createPlugin } from './plugin';
import { createRoute } from './route';

export const generateKitaRuntime = (
  routes: Route[],
  plugins: KitaPlugin[],
  providers: Provider[],
  schemas: JsonSchema[]
) => tst/* ts */ `
// This file is generated by Kita. Modifications will be overwritten.
//
// It is recommended to add this file to your .prettierignore, .eslintignore 
// and/or any other linter/formatter you may use.
// 
// You should also ignore this file from your version control system and prefer
// to run \`kita build\` every time you need to run/test your application.
// 
// Learn more at https://kita.js.org

import fp from 'fastify-plugin';
${plugins.map(toPluginImport)}
${providers.map(toProviderImport)}
${toAllMethod(routes)}
${groupRouteImports(routes)}
${groupRouteExports(routes)}
${routes.map(createRoute)}
${createPlugin(routes, plugins, providers, schemas)}
${createSchemaDefinitions(schemas)}
`;

export const toAllMethod = (routes: Route[]) =>
  routes.find((r) => r.method === 'ALL') ? `import { supportedMethods } from 'fastify/lib/httpMethods'` : '';

export const toProviderImport = (provider: Provider) => tst/* ts */ `

import * as ${provider.type} from '${provider.providerPath.replace(/\.(ts|js)x?$/, '')}';

`;

export const toPluginImport = (plugin: KitaPlugin) => tst/* ts */ `

import ${plugin.name} from '${plugin.importUrl}';

`;

export const toSchemaDefinitions = (schema: JsonSchema) => tst/* ts */ `

export const ${kSchemaDefinitions} = ${stringify(
  // Remove the $id to make it more readable without messing up the schema
  { ...schema, $id: undefined },
  { space: 4 }
)}

`;

export const toRouteImport = (r: Route) => tst/* ts */ `

import * as ${r.controllerName} from '${r.relativePath.replace(/\.(ts|js)x?$/, '')}';

`;

export const toRouteExport = ([path, names]: [path: string, names: string[]]) => tst/* ts */ `

export { ${names.join(', ')} } from '${path.replace(/\.(ts|js)x?$/, '')}';

`;

// HELPERS

export function groupRouteImports(routes: Route[]) {
  const imports: Record<string, string[]> = {};

  for (const route of routes) {
    const withoutExt = route.relativePath.replace(/\.(ts|js)x?$/, '');

    // biome-ignore lint/suspicious/noAssignInExpressions: easier syntax
    const path = (imports[withoutExt] ??= []);

    path.push(`${route.controllerMethod} as ${route.schema.operationId}`);
  }

  return routes.filter((v, i, a) => a.findIndex((t) => t.relativePath === v.relativePath) === i).map(toRouteImport);
}

export function groupRouteExports(routes: Route[]) {
  const imports: Record<string, string[]> = {};

  for (const route of routes) {
    const withoutExt = route.relativePath.replace(/\.(ts|js)x?$/, '');

    // biome-ignore lint/suspicious/noAssignInExpressions: easier syntax
    const path = (imports[withoutExt] ??= []);

    path.push(`${route.controllerMethod} as ${route.schema.operationId}`);
  }

  return Object.entries(imports).map(toRouteExport);
}

export function createSchemaDefinitions(schemas: JsonSchema[]) {
  const schema = schemas.find((schema) => schema.$id === kSchemaDefinitions);
  return schema && toSchemaDefinitions(schema);
}
